The idea of redecentralising git repositories again popped in my mind some time ago. It is nothing new and many people mention how actually funny this situation is. Especially during Github temporary unavailability... The reasons why companies use a centralised repository model can be narrowed to a synchronisation problem. No matter if we talk about a synchronisation between developer-to-developer or computer-to-computer (all kind of CIs and deployments hooks) it is much more easy to use a client-server model. With a single master node, a server, we can build other services around it easily, but, as every dependency, problems with it will cause problems with our infrastructure or workflows as well.

### First attempt
In my first design sketch, a system operated on a network with a star topology. Each node ran a local git server and broadcasted events related with code updates to the network. Other nodes pulled from the broadcasting node.

<i>A communication schema. Broadcasting an update event from a node:</i>
![Starbucket Star Topology](<%= s3_url('blog/starbucket-reintroduce-distributed-aspect-of-git/star-topology.gif') %>)

I used [Serf](https://www.serf.io) for a service discovery and bunch of scripts to execute git commands and glue all together.

The project was shutdown when I was trying to ‘hide’ Serf dependency by dockerizing the code. I faced some problems with accessing host network from a docker container.

### Final Architecture
To avoid as much dependencies as possible I decided to use NodeJS ecosystem. By picking only one language I narrowed dependencies to node-based dependencies only. I picked NodeJS becasue I found packages that solve most of low level infrastructure problems. Additionally I can use npm as a distribution channel.

The Package that is responsible for a service discovery and basic events broadcasting also provides a mechanism to elect (and reelect) a master node. Having this already provided I changed the system design to a master-slaves model, where the master role can be transferred dynamically to any other node.

There are 3 main components on each node:

  - Network Discovery - discovers nodes in a network and setups simple event-based communication. Done using [node-discover](https://github.com/wankdanker/node-discover) package.

  - Git server - a local git server. If a node is a master, it will inform the Network about any new changes, so other nodes can pull from this server. If a node is a slave, it will fetch to this server from currently chosen master server, based on Network events. Done using [node-git-server](https://github.com/gabrielcsapo/node-git-server) package.

  - Proxy server - proxy server will proxy all traffic from localhost to currently chosen master. If a node is a master, proxy will proxy traffic back to the same machine. Proxy will reconfigure itself automatically when a new master is announced. Done using [http-proxy](https://github.com/nodejitsu/node-http-proxy) package.

<i>A communication schema. Proxying all traffic to a master node for future distribution:</i>
![Starbucket Master-Slaves Topology](<%= s3_url('blog/starbucket-reintroduce-distributed-aspect-of-git/master-slaves-topology.gif') %>)


From a user perspective we always communicate only with a local proxy server. It will proxy to currently selected master node git server.

The heart of the system is a `onMasterChosen` method which handles election results of a new master node.

```javascript
onNewMasterChosen (netNodeInfo) {
  const newGitMasterServerIp = netNodeInfo.address
  const newGitMasterServerPort = netNodeInfo.advertisement.gitServerPort

  this.gatewayServer.restartWithTargetUrl('http://' + newGitMasterServerIp + ':' + newGitMasterServerPort)

  this.net.join('update-available', (data) => {
    this.gitServer.mirrorRepo(this.gatewayServer.getTargetUrl(), data.repoName)
  })
}
```

As we can see when a new master is selected, `gatewayServer` switches its target to that master node. Additionally we subscribe to a `update-available` events channel. When the event arrived a local gitServer pulls all data from the broadcasting node.

On the other hand, a master node, right after being elected, reconfigures itself as well. This is done by a `onPromoteToMaster` method.

```javascript
onPromoteToMaster () {
  this.net.leave('update-available')
  this.gatewayServer.restartWithTargetUrl('http://localhost:' + this.gitServerPort)
}
```

Important to notice here is that the node gateway reconfigures itself to point to git server on the same node.

Having a gateway server switching from one node to another (in some cases to itself) makes a master node and a slave node behaving nearly identical. Reducing differences between nodes roles greatly simplifies the system as a whole.


Starbucket source code is available on my [Github](https://github.com/kubenstein/starbucket).

Starbucket package can be installed via:

```
npm install -g starbucket
```
